---
layout: post
title:  "演进式架构"
description: 
categories:  读书笔记 
---

### 软件架构
既然变化是必然的，那么我们就只能因势利导地来利用它。  
软件开发的平衡是动态的，被不断打破和重建。  
康威逆定律：构建与目标系统架构相仿的团队结构，这样项目会更容易实现。  
演进：建立一个适用的并能在其所处的不断变化的环境中持续运行的系统。  

### 适应度函数
适应度函数：为架构特征提供客观的完整性评估。  
全系统适应度函数：当适应度函数对应的维度间存在冲突时，使用全系统适应度函数做出必要的权衡。  
架构维度：性能，可靠性，安全性，可操作性，代码规范，集成等。  
**上下文**  
原子适应度函数：针对单一的上下文执行，用例校验架构的某一维度。  
整体适应度函数：在共享的上下文中运行，综合检验架构的多个维度。  
**执行频率**  
触发式适应度函数：基于特定的事件执行。如：执行单元测试。  
持续式适应度函数：随真实交易的发生来模拟生产环境中发生的事务。从而验证系统在实际使用时的行为，并收集真实的数据。  
**结果**  
静态适应度函数：结果是固定的。  
动态适应度函数：结果依赖基于额外上下文变化的因素。  
尽早确定适应度函数及其优先次序。  


### 实施增量变更
微服务：一种无共享架构，每个服务都独立运行来消除技术耦合，因而能进行细粒度的变更。
可测试性：架构特征是否能够通过自动化测试验证其正确性。
自动化是持续评估的关键。使用部署流水线，架构师可以决定执行适应度函数的类别，时间和频率。
#### 持续集成与部署流水线
持续集成服务器包含一系列要执行的任务，包括单元测试，代码覆盖率统计，软件度量，功能测试等。
部署流水线鼓励开发人员将任务划分为不同的阶段。通常包括不同级别的应用测试，自动化环境准备和其他一系列验证职责。 
#### Scientist
现有行为封装到use块中（控制者），试验性行为放到try块中（候选者）。
挑选1%的随机用户运行try块，以覆盖到各种可能情况。
当执行代码时，最终用户总是收到use的结果，保证得到的结果与现有一致。如果try块返回与use块不一样的结果，那么会被记录下来。
当经过指定的一段时间期间，没有出现缓慢或者不匹配的情况，那么可以移除旧代码并保留新代码。
#### 假设驱动开发
在构思新功能的时候建立假设，推出几种不同的解决思路。将最终用户纳入构建流程，从他们的行为中学习并构建出对其真正有价值的系统。

### 架构耦合
演进式架构注重适当的耦合，即如何确定哪些架构维度间应该相互耦合来以最小的开销和成本最大程度地获益。
模块意味着逻辑分组，组件意味着物理划分。
架构量子：具有高功能内聚并可以独立部署的组件。它包括来支持系统正常工作的所有结构性元素。
在单体机构中，量子就是整个应用程序，每个部分都高度耦合。因此开发人员必须对其进行整型部署。
#### DDD与微服务
DDD定义了界限上下文：所有领域相关内容在该领域内是可见的，但不对其他界限上下文可见。
微服务架构在架构元素之间定义来物理界限上下文，封装来所有可能变化的部分。这种架构就是为了增量变更而设计的。
#### 大泥团架构（反模式）
系统高度耦合，当发生变更时会产生连锁副作用。
#### 微内核架构
定义来一个核心系统，核心系统对外提供API来通过插件丰富其功能。
通常将核心系统设计成单体应用，并在一些熟知的扩展点为插件创建钩子（hook）。通常把插件设计成独立可单独部署的组件。
插件必须和核心系统进行双向信息传递。插件间不需要互相协调。
通常，微内核架构包含一个注册表来跟踪安装的插件及其所支持的契约。
微内核架构的核心系统通常很庞大，但是很稳定。因为大部分的变更应该发生在插件上。
#### 事件驱动架构
通过消息队列将几个不相关的系统集成在一起。
常用的实现方式：代理模式和中介模式。
**代理模式**
始发事件：启动业务流程的事件
流程内事件：为了满足业务流程，在事件处理器之间传递的事件。
事件处理器：活跃的架构组件，执行事件的业务流程。当两个处理器需要协调是，它们通过队列传递消息。通常是无状态的，解耦的并且管理自身的数据。
服务间不需要协调，操作可以并行。本质是异步通信。
**中介模式**
包含一个额外的组件：做为中介的总线。
中介负责协调。任何需要和其他处理器通信的流程都是经由中介处理的。
事务性的协调是中介架构的重要优势。中介能保证流程的正确性。
中介充当了耦合点，它将所有受影响的服务绑定在一起。    
#### 微服务架构
在分层架构中，关注点在技术层面，或者说是在应用各部分的工作方式。（例如：持久性，UI，业务规则）
领域概念在分层架构的各层都会设计涉及，因此开发人员为了变更领域，必须修改每一层。
每个服务都围绕DDD的领域概念定义，并将技术架构和所依赖的其他组件（如：数据库）封装到限界上下文中，构建高度解耦的架构。通过消息和其他服务进行通信。
限界上下文代表某个业务上下文或工作流。
微服务高度去中心化，形成了一种无共享架构。通常重复好于耦合。
适当的耦合：集成（通过相互调用来传递信息）和服务模版（每个服务都需要包含监控，日志，认证/授权和其他一些基本能力）。

### 演进式数据
#### 共享数据库集成
扩展/收缩模式是平行变更模式的一个子集，广泛用于安全地对接口执行向下不兼容变更。
#### 数据耦合
事务是耦合的一种特殊形式。事务性耦合以具体的方式将各个组成部分绑定在一起，使得难以演进。通常能从事务边界中看出在实现层面上业务概念是如何耦合在一起的。
数据库事务好像强核力一样，将架构量子结合在一起。。
对于每个服务而言，小并不是必需的，能捕获有用的限界上下文才是关键。

### 构建可演进的架构
#### 演进机制
首先，必须识别出在演进中想保护的架构维度。
然后，为每个维度定义适应度函数。
最后，使用部署流水线自动化适应度函数。（以在项目中推进增量变更）
#### 改良现有架构
**适当的耦合和内聚**
除了技术层面的耦合，还必须考虑和保护系统中组件的功能内聚。功能内聚决定来组件重构后的最终粒度。
**工程实践**
一旦工程实践增强了，便能为更高级的能力提供基础。促进效率的提升，创造更好的反馈环并推动改进。
**适应度函数**
适应度函数是演进式架构的保护层。
将所有架构验证视为适应度函数，在定义自动化和其他有用的协同交互时能够达到更好的一致性。
#### 架构迁移 
“共享一切”的单体架构是迁移的起点。“尽可能少共享”的，基于服务的架构是迁移的目标。
确定正确的服务粒度是关键。粒度过小的组件则会导致过多的服务编排和消息通信所带来的开销以及服务间的相互依赖。
计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，除非该问题是由中间层太多导致的。
#### 演进式架构构建指南
**去除不必要的可变性**
不可变的基础设施：完全以程序的方式定义的系统。所有对系统的变更都必须通过代码完成，而不是修改运行中的操作系统。从运维的角度来看，整个系统是不可变的，一旦开始运转，就不会发生变化。
构建可演变的软件系统意味着尽可能地控制未知因素。。
每次在不是流水线执行时都会重新构建基础设施，从而尽可能积极地捕获具有破坏性的变更。
通过将开发环境构建成不可变的基础设施，开发人员能始终在相同的基础上工作。
**让决策可逆**
蓝绿部署
功能开关
**演进优于预测**
由于未知的未知问题，所有架构都将是迭代式的。
动态平衡导致的软件开发领域的不可预见性。
**构建防腐层**
除了复杂的遗留代码，项目还会因为早期的复杂度而在无意中引入技术债。
构建防腐层并提供接口，替换某个功能就变成了机械的操作。
构建即时防腐层来隔离库的更新。
#### 构建可牺牲架构
在构建新的软件系统时要做好抛弃它的计划。
#### 更新库与更新框架
开发人员的代码会调用库，而框架会调用开发人员的代码。
积极地更新框架依赖，消极地更新库。

### 演进式架构的陷阱和反模式
#### 代码复用和滥用（反模式）
复用软件更像是器官移植而不是拼装乐高积木。
代码复用性越高，其可用性越低。
重复优于耦合。
复用代码可以是资产，也可能是潜在的责任。
当耦合点妨碍来演进或其他重要的架构特征时，通过分叉或重复来打破耦合点。
#### 强制解耦
通过不同技术栈来构建服务是实现技术架构解耦的一种途径。
从大型组织的实用性管理角度来看：选择简单，中等和复杂三种技术栈做为标准，然后允许单个服务驱动技术栈的需求。
#### 发布过慢（陷阱）
演进的速度和生产周期成正比，生产周期越短，演进越快。
