正在学习 Linux，记录一下学习历程。

选取，排序，组合，变换

## 选取包含特定模式的行：grep

从标准输入或者文件中读取数据，抽取所有包含特定模式的行，并写到标准输出

支持正则表达式匹配模式

选项：

-c  统计所抽取行的数量

-i  忽略大小写

-n  所选取行在数据流中的位置（每一行前会显示此行在数据中的行号）

-l  列举文件名（不显示行，而是显示包含匹配模式的文件名）

-L  显示不包含匹配模式的文件名

-w  只搜索完整的单词

-v  选取不包含指定模式的所有行

-x  完全由搜索模式构成的行

-r  搜索整个目录树

-s  以超级用户身份登录

## 选取以特定模式开头的行：look

搜索以字母顺序排列的数据，并查找所有以特定模式开头的行

选项：

-d  忽略标点符号和其他特殊字符

-f  忽略大小写

ps：look 不能从标准输入读取数据，它必须从文件中读取数据。严格来讲，它并不是一个过滤器。

原因在于，对于标准输入，程序每次只能读取一行，但是 look 使用了二分查找，要求必须同时访问所有数据。

因此，可以在管道开头使用 look，但是不能在管道中间使用。

## 排序数据：sort

排序数据以及查看数据是否已经排序

选项;

-o  指定输出文件（排序完成后，才会执行写入输出文件。输出文件可以是原文件，即达到用排序后的数据替换原文件的目的）

-d  只查看字母，数字和空白符（空格和制表符），忽略标点符号对排序的影响。

-f  忽略大小写

-n  识别行开头或者字段开头的数字，并按数字数值排序

-r  按反向顺序排序（默认是升序）

-u  相同的行只留下一行

-c  不排序数据，只检查数据是否已经有序（若有序，无消息，。若无序，有提示消息）

-cu  检查数据是否有序且行唯一

## 查找重复行：uniq

一行一行地检查数据，查找连续重复的行

uniq file1 file2

将 file1 中的连续重复的行只保留一行，输出到 file2 中

选项：

-d  只查看重复行

-u  只查看唯一（非重复）行

-c  统计每行重复次数

ps：uniq 的输入通常是有序的，若不有序，则不连续的重复行无法统计或去除。因此通常在 uniq 之前使用 sort。

## 合并两个文件中有序数据：join

基于特定字段的值将两个有序文件组合在一起

联接：基于匹配字段组合两组数据

联接字段：用来联接的具体字段（join 中默认是第一个字段）

分界符：分隔每个字段的字符（join 中默认是空白符）

join file1 file2

在 file1，file2 中查找行对（联接字段值相同的行），对于每个行对来说，join 生成包含 3 部分的输出：公共联接字段值，file1 中行的其他部分，file 中行的其他部分。没有结成行对的行被抛弃。

选项：

-a1  不抛弃 file1 中所有的行（即使没有结成行对，也输出此行）

-a2  不抛弃 file2 中所有的行（即使没有结成行对，也输出此行）

-v1  只输出 file1 中不匹配的行（即没有结成行对的行）

-v2  只输出 file2 中不匹配的行（即没有结成行对的行）

-i  忽略大小写

-1  指定第一个联接字段（后跟字段编号）

-2  指定第二个联接字段（后跟字段编号）

ps：以常规方式使用 join（没有-a 选项）时，所获得的结果称为内联接，输出只包含联接字段匹配的行。

当使用-a1 或-a2 选项时，所获得结果称为外联接（分左外联接，右外联接），输出还包含联接字段不匹配的行。

## 由偏序创建全序：tsort

偏序：每一个约束都称为一个偏序，因为只指定了一些（不是全部）活动的顺序

全序：指定全部活动顺序的主列表

tsort file

file 的每一行必须包含一对由空白符（空格或制表符）分隔的字符串，每一对字符串代表一个偏序。

tsort 将 file 中的一组偏序转换成一个全序。

ps：若偏序组中有循环，则显示错误信息。

## 在二进制文件中搜索字符串：strings

文本文件：只包含可显示字符的文件（每行结束都有一个新行字符），也称为 ASCII 文件。

二进制文件：任何非文本的非空文件（至少包含少量非文本数据），如可执行程序，对象文件，图像，声音文件，视频文件等。

strings 是为了让程序员显示嵌在可执行程序和对象文件中的字符串而创建的工具。

选项：

-  指定要显示字符串的最小长度

## 转换字符：tr

可以对字符进行 3 种不同的运算：

1. 将字符改变成其他字符

2. 积压字符，将多个连续出现的字符替换为一个字符

3. 删除指定的字符

tr 是一个纯过滤器，只能从标准输入读取数据，向标准输出写入数据。

tr a A

将输入数据中所有的 a 转换为 A

tr abcd AB

将输入数据中所有的 abcd 转换为 ABBB

tr a-z A-Z

将输入数据中所有的小写字母转换为大写

tr '\r' '\n'

将输入数据中所有的回车改为新行

选项：

-s  积压字符，多个字符应该替换为一个单独的字符（如：tr -a aaa A，将 aaa 转换为 A）

-d  删除指定的一组字符（如：tr -d '()'，删除所有的小括号）

-c  匹配所有不再第一组字符中字符，并进行替换为指定字符（如：tr -c ' \n' X，将除空格和新行字符以外的所有字符都替换为 X）

## 非交互式文本编辑：sed

sed 是一个可移植的，与 shell 无关的语言编辑器，被设计用来对数据流执行文本转换

需要提前设计命令，然后将命令发送给程序，程序再自动地执行命令，可以自动执行大量任务。

输入流：当数据是由程序读取时，称数据是输入流

输出流：当数据是由程序写入时，称数据是输出流

按以下 3 个步骤从头到尾逐行处理数据：

1. 从输入流读取一行

2. 执行指定的命令，对该行进行必要的变换

3. 将该行写入到输出流中

选项：

-i  改变原始文件（sed 将输出保存到一个临时文件，数据全部处理完成后，将临时文件复制到原始文件）

-e  指定所需的命令，可有多个-e

命令：

```
s/search/replacement/
```

如：s/abc/ABCD，将搜索字符串并 abc 替换为 ABCD

只改变每一行上第一个出现的匹配字符串

```
s/search/replacement/g
```

在命令末尾加上 g，改变所有的匹配字符串

```
5s/search/replacement/g
```

指定对第 5 行进行操作

```
5,9s/search/replacement/g
```

指定对 5 ～ 10 行进行操作

```
5,$s/search/replacement/g
```

指定从第 5 行开始到最后一行进行操作

```
/ok/s/search/replacement/g
```

指定对那些包含 ok 的行进行操作

ps：命令通常用‘’（单引号）括起。
