#### 副作用
副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。
- 更改文件系统
- 数据库更改
- 发送一个 http 请求
- 可变数据
- 打印/log
- 获取用户输入
- DOM 查询
- 访问系统状态
概括来讲，只要是跟函数外部环境发生的交互就都是副作用。

#### 追求纯的理由
- 可缓存性
- 可移植性/自文档性。完全是自给自足的，将依赖作为参数传递，强迫注入依赖
- 可测试性
- 合理性。引用透明，一段代码可以替换成它所执行的结果，等式推导
- 并行代码。不会因副作用进入竞争态

#### curry
只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
策略性地把要操作的数据放到最后一个参数里。
预加载函数：通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。也叫局部调用，大量减少样板文件代码。

#### compose
组合某种类型的两种元素，产生一个该类型的新元素。两个函数组合后返回一个新函数
结合律：var associative = compose(f, compose(g, h)) == compose(compose(f, g), h)
函数的执行顺序都是h -> g -> f

#### 声明式代码
与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。
用多种方式解析一个表达式并得到相同的结果。为潜在的代码更新提供了支持，使得应用代码可以成为一种高级规范。
声明式代码指明的是做什么，而不是怎么做。

#### 类型签名
类型是让所以不同背景的人都能高效沟通的元语言。暴露出函数的行为和目的。

#### 容器
能够装载任意类型的值。
一旦容器里面有了值，就需要一种方法来让别的函数能够操作它。在不离开容器的情况下操作容器里面的值。
functor是一个签了合约的接口。
释放容器中的值，任何事物都有个最终尽头，那些产生副作用的函数终将被执行。
应用程序所做的工作就是获取，更改和保存数据直到不再需要它们。
将产生副作用的函数交给调用者。

#### Monad
结合律： compose(join, map(join)) == compose(join, join)
结合律关心的是如何让内层或外层的容器类型 join，然后取得同样的结果