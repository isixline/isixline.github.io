[{"title":"go hello world","url":"/2021/09/25/2021-09-25-go-hello-world/","content":"\n## install\n#### 安装\n```shell\nbrew install go\n```\n#### 检查版本\n```shell\ngo version\n```\n\n## hello world\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main()  {\n\tfmt.Println(\"Hello Word\")\n}\n```\n\n## run\n\n```\ngo run main.go\n```\n\n## build\n\n```\ngo build main.go\n```\n\n## 组织结构\n\n- package：一个包由位于单个目录下的一个或多个.go 源代码文件组成, 目录定义包的作用。每个源文件都以一条 package 声明语句开始，\n- .go文件   \n  main 包比较特殊，它定义了一个独立可执行的程序，而不是一个库。  \n  在 main 里的 main 函数是整个程序执行时的入口。  \n  必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过必须恰当导入需要的包。  \n\n## gofmt\n\nGo 语言在代码格式上采取了很强硬的态度。  \ngofmt 工具把代码格式化为标准格式，并且 go 工具中的 fmt 子命令会对指定包, 否则默认为当前目录, 中所有.go 源文件应用 gofmt 命令。\n\n## goimports\n\n可以根据代码需要, 自动地添加或删除 import 声明。  \n获取goimports\n```\ngo get golang.org/x/tools/cmd/goimports\n```\n","tags":["go"]},{"title":"单元测试","url":"/2021/09/25/2021-09-25-unit-test/","content":"\n## 什么是单元测试\n在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。\n\n程序单元是应用的最小可测试部件，但单元是一个相对概念，比如：一个方法，一个类都可以称之为一个单元。\n\n相对于单元测试的，是集成测试，E2E测试，是针对整个系统完整进行一次业务操作的测试。\n\nps：\n另一种测试分类：\n- 小型测试，针对单个函数的测试，关注其内部逻辑，mock所有需要的服务。小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告。\n- 中型测试，验证两个或多个制定的模块应用之间的交互大型测试，也被称为“系统测试”或“端到端测试”。\n- 大型测试在一个较高层次上运行，验证系统作为一个整体是如何工作的。\n\n## 单元测试的目的\n对最小组成部分进行测试，保证这些部件安全可用。\n\n再使用这些部件串联起来，组成更大的部件，这个被组合成的大部件就只需要关注内部小部件的串联关系就好。  \n保证测试覆盖足够广且最少进行不必要的重复测试。\n\n## 一个测试（以JUnit为例）\n```java\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n    @InjectMocks\n    private UserService userService;\n\n    @Mock\n    private UserRepository userRepository;\n\n    @Test\n    void should_throw_not_found_when_get_not_exists_user() {\n        // given\n        Mockito.when(userRepository.findById(eq(\"test-user-id\")))\n                .thenReturn(Optional.empty());\n        // when\n        BaseException exception = assertThrows(UserException.class, () -> {\n            userService.get(\"test-user-id\");\n        });\n\n        // then\n        assertEquals(\"user_not_found\", exception.getMessage());\n        assertEquals(BaseException.Type.NOT_FOUND, exception.getType());\n    }\n\n}\n```\n#### 测试范围\n所有对外暴露出去的public方法\n\n#### 测试目标\n理论上单元测试应该测试该方法中的所有逻辑分支。\n\n但如果已经存在覆盖happy path的集成测试，那么单元测试应当针对于该业务方法中的异常。  \n集成测试注重该业务操作的流程顺利可执行，单元测试注重维护对应业务方法是否正确保护了业务数据。不同类型的测试相互配合，有所侧重。\n\n当然，如果写相当完善的单元测试是相当好的，只是在精力，时间，维护性上要有所权衡。\n\n#### 命名\n- UserServiceTest是UserService的测试，保持同名并加Test后缀\n- should_throw_not_found_when_get_not_exists_user以should_xxx_when_xxx命名，语义不清楚时还可加上_given_xxx\n\n#### mock使用\n这里使用Mockito的mock框架。\n- @ExtendWith(MockitoExtension.class)，其中@ExtendWith注解是由Jupiter（JUnit5）提供的标记接口。这是在测试类或方法上注册自定义扩展的方法，目的是让Jupiter测试引擎调用给定类或方法的自定义扩展。\n- @Mock：使用注解创建一个Mock\n- @InjectMocks：创建一个实例，是被测试实例，用@Mock（或@Spy）注解创建的mock将被注入到用该实例中\n\n定制mock对象行为：  \n这里使用了when(...).thenReturn(...) 方法链来定义一个行为  \nps：\n一个有趣的地方, when(...).thenReturn(...).thenReturn(...)方法链可以指定多个返回值, 如果多次调用指定的方法, 那么这个方法会依次返回这些值。\n\n#### 断言检查\n由于在该例子中是检验异常，所以使用了assertThrows来检查异常类型并获取该异常。  \n对于异常内容的检查使用了assertEquals。\n\nassertEquals是一个重载方法，可以断言各种支持的数据类型，在使用中只需考虑语义而不需要特意区分不同数据类型所使用的方法。  \nassertEquals(expected, actual)\n","tags":["test"]},{"title":"Python String","url":"/2021/09/07/2021-09-07-python-string/","content":"\n## 字符串\n```\nprint('abc')\nprint(\"abc\")\nprint(\"I'm good!\")\nprint('I\\'m \\\"OK\\\"!')\nprint(r'\\t')\nprint('''line1\nline2\nline3''')\n```\n\n## 字符编码\n在Python3中字符串是以Unicode编码的。  \n对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符。\nPython对bytes类型的数据用带b前缀的单引号或双引号表示：\n```\nx = b'ABC'\n```\n以Unicode表示的str通过encode()方法可以编码为指定的bytes\n```\n'ABC'.encode('ascii')\n```\n如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：\n```\nb'ABC'.decode('ascii')\n```\n\n## 格式化\n```\n'Hello, %s' % 'world'\n```\n在字符串内部，%s表示用字符串替换，%d表示用整数替换，%f表示用浮点数替换，\n有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n```\nprint('%2d-%02d' % (3, 1))\nprint('%.2f' % 3.1415926)\n```\n格式化整数和浮点数还可以指定是否补0和整数与小数的位数。  \n```\nAge: %s. Gender: %s' % (25, True)\n```\n如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。  \n```\ngrowth rate: %d %%' % 7\n```\n转义，用%%来表示一个%。\n```\n'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)\n```\n另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……\n","tags":["python"]},{"title":"Python Overview","url":"/2021/09/06/2021-09-06-python-overview/","content":"\n## 安装python3\nMac 自带 python2   \n安装python3\n```\nbrew install python3\n```\n\n## python 命令环境\n#### 进入命令环境\n```\npython3\n```\n#### 退出命令环境\n```\nexit()\n```\n或\ncrl + d\n\n\n## Hello world\n#### 命令行\n```\nprint('Hello world')\n```\n#### 通过python解释器执行python文件\n```\npython3 hello.py\n```\n#### 直接执行python文件\n```\n#!/usr/bin/env python3\n\nprint('Hello world')\n```\n```\nchmod a+x hello.py\n./hello.py\n```\n\n## 输入和输出\n#### 输入\n```\nname = input()\n```\n在按下回车前输入的内容都会以字符串的形式存储在name中\n```\nname = input('Please enter your name: ')\n```\n提示语\n#### 输出\n```\nprint('a')\n```\n```\nprint('a', 'b', 'c')\n```\n多个字符串时，输出默认以空格分隔（如：'a b c'）\n\n## 注释\n```\n# 这是一段注释\n```\n\n## 缩进\n```\na = 100\nif a >= 0:\n    print(a)\nelse:\n    print(-a\n```\n以缩进标识代码块\n\n## 数据类型\n## 整数\n十进制：0，1，-10\n十六进制：0xff00（用0x前缀和0-9，a-f表示）\n## 浮点数\n小数：0.1，-11.1\n科学计数法：1.23e9（1.23x10<sup>9</sup>），1.2e-5（0.000012）\n## 字符串\n```\nprint('abc')\nprint(\"abc\")\nprint(\"I'm good!\")\nprint('I\\'m \\\"OK\\\"!')\nprint(r'\\t')\nprint('''line1\nline2\nline3''')\n```\n## 布尔值\n```\nTrue and False\nTrue or False\nnot True\n```\n## 空值\nNone\n\nps: Python的整数没有大小限制，浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。\n\n## 变量与常量\n#### 变量\n变量名是大小写英文、数字和_的组合，且不能用数字开头\n```\na = 'ABC'\nb = a\na = 123\n```\nPython解释器做了这几件事情：\n1. 在内存中创建了一个'ABC'的字符串。\n2. 在内存中创建了一个名为a的变量，并把它指向'ABC'。\n3. 在内存中创建了一个名为b的变量\n4. 把b指向a所指向的数据\n5. 在内存中创建了一个123的整数\n6. 把a指向123\n最后print(a)为123，print(b)为'ABC'\n#### 常量\n通常用全部大写的变量名表示常量。 \n```\nPI = 3.14159265359\n```\n但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变\n\n## list\nlist是一种有序的集合，可以随时添加和删除其中的元素\n#### 基本操作\n```\nclassmates = ['Michael', 'Bob', 'Tracy']\n```\n```\nlen(classmates)\n```\n```\nclassmates[-1]\n```\n```\nclassmates.append('Adam')\n```\n```\nclassmates.insert(1, 'Jack')\n```\n```\nclassmates.pop()\n```\n```\nclassmates.pop(1)\n```\n#### 元素数据类型\n```\nl = ['Apple', 123, True]\n```\n```\ns = ['python', 'java', ['asp', 'php'], 'scheme']\n```\n\n## tuple\n另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。  \n因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n```\nt = (1, 2)\n```\n```\nt = (1,)\n```\n\n## dict\ndict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n```\nd = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\nprint(d['Michael'])\nd['Adam'] = 67\n```\n判断key是否存在\n```\n'Thomas' in d\n\nd.get('Thomas')\nd.get('Thomas', -1)\n```\n删除key-value\n```\nd.pop('Bob')\n```\ndict的key必须是不可变对象，如字符串、整数。\n这是因为dict根据key来计算value的存储位置。\n\n## set\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n```\ns = set([1, 1, 2, 2, 3, 3])\n```\n重复元素在set中自动被过滤。\n```\ns.add(4)\ns.remove(4)\n```\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n```\ns1 & s2\n\ns1 | s2\n```\n\n\n## 条件判断\n```\nage = 3\nif age >= 18:\n    print('adult')\nelif age >= 6:\n    print('teenager')\nelse:\n    print('kid')\n```\n```\nif x:\n    print('True')\n```\n只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。\n\n## 循环\n#### for...in\n依次把list或tuple中的每个元素迭代出来\n```\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n```\n```\nsum = 0\nfor x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:\n    sum = sum + x\nprint(sum)\n```\n生成一个整数序列\n```\nlist(range(5))\n```\n#### while\n```\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\nbreak：提前结束循环。\ncontinue：跳过当前的这次循环，\n\n\n## 函数\n#### 内置函数\n数学计算\n```\nabs(-100)\n\nmax(1, 2, 3)\n\nmin(1, 2, 3)\n```\n数据类型转换\n```\nint('123')\nint(12.3)\n\nfloat('12.3')\n\nstr(1.23)\n\nbool(1)\n```\n类型检查\n```\nisinstance(x, (int, float))\n```\n#### 定义函数\n```\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n空函数\n```\ndef nop():\n    pass\n```\n返回多个值\n```\nimport math\n\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\n```\n返回值是其实是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。\n##### 默认参数\n```\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n```\n必选参数在前，默认参数在后。\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。\n#### 可变参数\n```\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\n calc(1, 3, 5, 7)\n```\n可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。\n#### 关键字参数\n而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。\n```\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n\nperson('Adam', 45, gender='M', job='Engineer')\n```\n如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n```\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\n\ndef person(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n```\n和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n\n\n\n\n\n\n","tags":["python"]},{"title":"React Router","url":"/2021/08/24/2021-08-24-react-router/","content":"\n## react-router 和 react-router-dom\n\n- react-router：提供了router的核心api。如Router、Route、Switch等\n- react-router-dom：基于react-router，并提供了BrowserRouter、HashRouter，Link等组件，可以通过dom操作触发事件控制路由\n\nps：react-router-dom里包含了react-router的依赖，无需重复引入\n\n## 一个例子\n\n```javascript\n <Router>\n    <Route path=\"/\" component={App}>\n        <Route path=\"about\" component={About}/>\n        <Route path=\"inbox\" component={Inbox}>\n            <Route path=\"messages/:id\" component={Message}/>\n        </Route>\n    </Route>\n</Router>\n```\n\nps：当path以\"/\"开头，为绝对路径，否则为相对路径(如：/inbox/message/:id)\n\n## Router\n\n当渲染组件时，Router 会自动向 Route 组件中注入一些有用的信息，尤其是路径中动态部分的参数，如：id。\n\n```javascript\n    const id = this.props.params.id;\n```\n\n## IndexRoute\n默认路由\n```javascript\n<IndexRoute component={Home}/>\n```\n\n## Redirect\n从跳转 /inbox/messages/:id 到 /messages/:id \n```javascript\n<Redirect from=\"messages/:id\" to=\"/messages/:id\"/>\n```\n\n## hook：onEnter onLeave\n\n## 页面跳转\n组件方式\n```javascript\n <Link to=\"/about\">关于我们</Link>\n```\n\n被Route包裹的组件，代码内调用\n```javascript\nthis.props.history.push(\"/about\")\n```\n\n## 路由参数获取\n被Route包裹的组件\n```javascript\nthis.props.location\n```\n\n","tags":["react"]},{"title":"创建react项目","url":"/2021/08/23/2021-08-23-create-react-app/","content":"\n## 安装create-react-app工具\n\n```shell\nnpm install -g create-react-app\n```\n\n## 使用create-react-app创建新项目\n```shell\nnpx create-react-app my-new-app\n```\n\n安装依赖\n```shell\nnpm install\n```\n\n启动项目\n```shell\nnpm start\n```\n","tags":["react"]},{"title":"前端基础环境配置","url":"/2021/07/22/2021-07-22-frontend-basic-dev-env/","content":"\n## node安装\n在官方下载网站下载 pkg 安装包，直接点击安装即可。https://nodejs.org/en/download/\n\n#### 查看当前node版本\n```shell\nnode -v \n```\n\n## npm安装\nnpm在Node.js安装的时候顺带装好了\n\n#### 查看npm版本\n```shell\nnpm -v\n```\n\n## node版本管理工具n\n#### 安装\n```shell\nsudo npm install -g n\n```\n\n\n#### 升级node到最新稳定版\n```shell\nsudo n stable\n```\n\n#### 升级node到指定版本\n```shell\nsudo n v10\n```\n\n#### 切换当前使用的node版本\n```shell\nn\n```\n选择指定版本\n\n","tags":["前端"]},{"title":"时间与时区","url":"/2021/07/15/2021-07-15-time-zone/","content":"## 标准时间\n\n#### 协调世界时（UTC）\n\nCoordinated Universal Time，使用原子钟来计算时间。\n\n“Z”是协调世界时中 0 时区的标志。\n\n🌰 “09:30 UTC”就写作“09:30Z”或是“0930Z”。\n\n🌰 “14:45:15 UTC”则为“14:45:15Z”或“144515Z”。\n\n#### 时间戳/unix 时间戳\n\n是从 1970 年 1 月 1 日（UTC/GMT 的午夜）开始所经过的秒数。\n\n最初计算机操作系统是 32 位，而时间也是用 32 位表示，2147483647。\n换算下来大概是 68 年，实际上到 2038 年 01 月 19 日 03 时 14 分 07 秒，便会到达最大时间。\n\n因为用 32 位来表示时间的最大间隔是 68 年，而最早出现的 UNIX 操作系统考虑到计算机产生的年代和应用的时限综合取了 1970 年 1 月 1 日作为 UNIX TIME 的纪元时间。\n\n但是不用担心，64 位操作系统可以表示到 292,277,026,596 年 12 月 4 日 15 时 30 分 08 秒，哪怕地球毁灭那天都不用愁不够用了。\n\n## 太阳时间\n\n#### 时区\n\n时区是地理上的一个区域，在该区域遵守同一的标准时间。\n\n地球是自西向东自转的，因此东边会比西边先看到太阳。从经验上讲，太阳升降是一天的时间周期。在这种时间度量方式下，时间就不是一个绝对的概念了。\n\n不同经度地区存在时差，但严格区分实在太不方便了。实际生活中，不需要到分和秒那么精确，1 小时内的误差是可以被接受的。\n\n因此，1884 年在华盛顿召开的国际子午线会议上，规定将全球划分为 24 个时区(东、西各十二个时区)，其中以英国格林尼治天文台旧址作为零时区，每个时区横跨经度 15 度，时间恰好为 1 小时，而东、西第 12 时区各跨经度 7.5 度，以东、西经 180 度为界。每个时区内时间，统一以该时区的中央经线的时间为主，相邻的两个时区间总是相差一个小时，这就是时区的由来。\n\n事实上，时区的划分并不是一个严谨的事情，常见的情况是：一个国家或者一个省份同时跨着 2 个或者更多的时区。\n以中国为例，差不多横跨 5 个时区，理论上在国内应该有 5 个时间，但为了使用起来方便，我们统一用一个时区。\n东八区覆盖了我国的绝大多数人口，且覆盖了我国绝大多数重要城市。因此选取东八区为“中国时间”，又因为北京是我国首都，所以称之为“北京时间”。\n\n#### UTC 偏移\n\nUTC 偏移量是协调世界时（UTC）和特定地点的日期与时间差异，其单位为小时和分钟。\n它通常以 ±[hh]:[mm]、±[hh][mm]、或 ±[hh]的格式显示。\nUTC+08:00 是比世界协调时间快 8 小时的时区。\n\n#### GMT\n\nGreenwich Mean Time 格林尼治标准时间。这个地方的当地时间过去被当成世界标准的时间。\nGMT 是前世界标准时，UTC 是现世界标准时。UTC 比 GMT 更精准，以原子时计时，适应现代社会的精确计时。但在不需要精确到秒的情况下，二者可以视为等同。\n格林尼治刚好在 0 时区上。\n\nGMT = UTC+0\n\n#### 夏令时\n\nDST（Daylight Saving Time），夏令时又称夏季时间，或者夏时制。使用夏令时的国家在夏季使用夏令时，标准时间也因此被相应地称为冬季时间。\n\n是为节约能源而人为规定地方时间的制度。一般在天亮早的夏季人为将时间提前一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。\n\n在施行夏令时的国家，一年里面有一天只有 23 小时（夏令时开始那一天），有一天有 25 小时（夏令时结束那一天），其他时间每天都是 24 小时。\n\n从过去的 100 多年来看，夏令时往往是在国家发生严重危机（如战争和能源短缺）的情况下才会受到青睐。而在相对和平的近 10 年里，这种时间制度则变得越来越不受欢迎。它会使得人们的生物钟被扰乱，常常陷入睡眠不足的情况，不仅对人体健康有害、导致车祸，还会对旅游、航空领域造成极大的混乱。\n另外，冬、夏令时究竟能否起到节能的作用，也仍有待商榷。美国一项截至 2014 年 3 月的研究表明，这种时间转换制度最多能在 3、4 月帮助美国减少 1%的用电量，而美国国家标准局则认为，夏令时对用电量没有丝毫影响。\n在俄罗斯，此前的一份报告也显示，夏令时帮助俄罗斯每年节约的电量，仅相当于两三个火力发电厂的发电量，十分的“鸡肋”。\n\n#### 本地时间\n\n在日常生活中所使用的时间我们通常称之为本地时间。\n这个时间等于我们所在（或者所使用）时区内的当地时间，它由与世界标准时间（UTC）之间的偏移量来定义。\n这个偏移量可以表示为 UTC- 或 UTC+，后面接上偏移的小时和分钟数。\n\n## 时间格式\n\n#### ISO 8601\n\n国际标准 ISO 8601，是国际标准化组织的日期和时间的表示方法。\n\n🌰 1970-01-01T00:00:00Z\n\n- 年 YYYY\n- 月 MM\n- 日 DD\n- T 标识为 UTC\n- Z 标识时区为 0\n\n#### instant（Java）\n\nInstant.now()使用等是 UTC 时间\n\nLocalDate、LocalDateTime 的 now()方法使用的是系统默认时区。\n\n#### TIMESTAMP\n\n存储时，MySQL 将 TIMESTAMP 值从当前时区转换为 UTC 时间进行存储，查询时，将数据从 UTC 转换为检索的当前时区。\n\n默认情况下，每个连接的当前时区是服务器的时间。时区可以根据每个连接进行设置。只要时区设置保持不变，就可以得到存储的相同值。\n\n只要写入和读出时的时区设置一致，就能获取到一致的值。\n\n#### 数据库连接时的时间转换\n\n每次创建会话前，先取服务端的时区 STZ 和客户端时区 CTZ(比如 serverTimezone=GMT+8)\n如果 CTZ 没有设置就尝试将 STZ 转换为客户端时区，作为当前会话的时区。\n\n时间类型的处理发生在 SQL 参数绑定阶段，Java 日期时间类型被转换为 SQL 语句(字符串)\n","tags":["时间"]},{"title":"Hello World","url":"/2021/06/27/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["tag0","tag1"]},{"title":"基础环境配置","url":"/2021/06/20/2021-06-20-basic-dev-env/","content":"\n## 安装Homebrew \nhttps://brew.sh/index_zh-cn\n\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n## jdk 安装\njdk1.8下载地址\nhttps://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html\n\n查看安装路径：/usr/libexec/java_home -V\n\n默认安装路径：/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home\n\n进入 ～目录\n\n编辑.bash_profile，加入以下内容\n```\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home\n\nPATH=$JAVA\\_HOME/bin:$PATH:.\n\nCLASSPATH=$JAVA\\_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.\n\nexport JAVA_HOME\n\nexport PATH\n\nexport CLASSPATH\n```\n执行 source ~/.bash_profile  使配置生效。\n\n查看 java 版本：java -version\n\n## gradle 安装\n#### 使用 brew 安装 gradle\n```\nbrew install gradle\n```\n\n#### 查看 gradle 版本\n```\ngradle -v\n```\n\n## git 安装\n#### 使用 brew 安装 git\n```\nbrew install git\n```\n\n#### 配置用户信息\n```\ngit config --global user.name yourName\ngit config --global user.email yourEmail\n```\n\n#### 配置ssh\n查看是否有ssh配置\n```\ncd ~/.ssh\n```\n\n生成ssh\n```\nssh-keygen -t rsa -C \"yourEmail\"\n```\n会在 .ssh 下生成 id_rsa 和 id_rsa.pub\n\n将 id_rsa.pub 中的内容配置在github中\n\n## docker 安装\n#### 使用 brew 安装\n```\nbrew install --cask docker\n```\n\n#### 下载安装\nhttps://hub.docker.com/editions/community/docker-ce-desktop-mac\n\n## 使用zsh\n安装 oh-my-zsh\n```\ngit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\n```\n\n目录下没有.zshrc\n```\ntouch .zshrc\ncp ~/.zshrc   ~/.zshrc.orig\n```\n\n创建zsh配置文件\n```\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n\n配置兼容bash环境变量\n```\n.zshrc 文件中添加source ~/.bash_profile\n```\n\n修改默认shell\n```\nchsh -s /bin/zsh\n```\n修改zsh主题\n.zshrc 文件 添加 ZSH_THEME=gnzh\n\n"},{"title":"阿里云人机校验","url":"/2021/05/29/2021-05-29-aliyun-captcha/","content":"\n## 阿里云人机校验（滑动校验）\n[官方文档](https://help.aliyun.com/document_detail/121893.html?spm=5176.2020520162.0.dexternal.73285fb0WkhLIZ)\n\n### 验证流程\n- 客户端 -> 阿里云服务器：获取验签所需参数\n- 客户端 -> 应用服务器：验证所需参数和业务代码\n- 应用服务器 -> 阿里云服务器：验签\n\n### 配置\n#### 创建AccessKey\n访问密钥AccessKey（AK）相当于登录密码，只是使用场景不同。\n\nAccessKey用于程序方式调用云服务API，而登录密码用于登录控制台。\n- AccessKey ID用于标识用户。\n- AccessKey Secret是用来验证用户的密钥。AccessKey Secret必须保密。\n\n#### 添加captcha配置\n- 配置名称（后期可修改）\n- 高峰期OPS（貌似随便填）\n- 业务类型 + 验证方式 + 使用场景 （组成一个配置，也就是最多可以有2 * 3 * 6个配置，配置成功后不可删除）\nps：配置不可删除，不使用，不付费。\nps：自2020年9月起，阿里云人机验证服务接入集成模块已升级为新版，需使用新版代码集成。\n\n\n### 前端代码集成\n#### 引入js包\n```html\n    <script src=\"https://g.alicdn.com/AWSC/AWSC/awsc.js\"></script>\n```\n\n#### 标识dom\n```html\n    <div id=\"nc\"></div>\n```\n#### 初始化滑块\n```js\n    // 实例化nc\n    AWSC.use(\"nc\", function (state, module) {\n        // state标识状态，首次实例化会加载外部js，timeout为获取超时，loaded为已加载\n        if (state === 'timeout') {\n            console.log('nc timeout')\n        }\n\n        // 初始化\n        const nc = module.init({\n            // 应用类型标识,配置管理页签可找到对应的appkey值\n            appkey: \"CF_APP_1\",\n            //使用场景标识，配置管理页签可找到对应的scene值\n            scene: \"register\",\n            // 声明滑动验证需要渲染的目标ID。\n            renderTo: \"nc\",\n            //前端滑动验证通过时会触发该回调参数。会话ID（sessionId）、签名串（sig）、请求唯一标识（token）需随业务请求一同发送至端验签\n            success: function (data) {\n                window.console && console.log(data.sessionId)\n                window.console && console.log(data.sig)\n                window.console && console.log(data.token)\n            },\n            // 滑动验证失败时触发该回调参数。\n            fail: function (failCode) {\n                 window.console && console.log(failCode)\n            },\n            // 验证码加载出现异常时触发该回调参数。\n            error: function (errorCode) {\n                 window.console && console.log(errorCode)\n            }\n        });\n\n```\n#### 其他参数\n- language，语言，默认cn\n- width，滑动条宽度，默认300\n- height，滑动条高度（亲测未生效），默认34\n- fontSize，字体大小，默认12\n- hideErrorCode，隐藏验证时的错误码，默认false\n- upLang，自定义文案\n- test，用于测试验证码的不同状态（module.TEST_PASS，module.TEST_BLOCK\n\n#### nc对象\n- reset\n- hide\n- show\n\n### 后端代码集成\n#### 引入依赖\n```gradle\n    compile 'com.aliyun:aliyun-java-sdk-core:4.5.1'\n    compile 'com.aliyun:aliyun-java-sdk-afs:1.0.1'\n```\n\n```java\n    public class CaptchaService {\n    public static final String PRODUCT = \"afs\";\n    public static final String END_POINT = \"afs.aliyuncs.com\";\n\n    @Value(\"${aliyun.captcha.region-id}\")\n    private String regionId;\n\n    @Value(\"${aliyun.captcha.access-key-id}\")\n    private String accessKeyId;\n\n    @Value(\"${aliyun.captcha.access-key-secret}\")\n    private String accessKeySecret;\n\n    @Value(\"${captcha.enabled}\")\n    private boolean captchaEnabled;\n\n    private IAcsClient client;\n\n    public IAcsClient getClient() {\n        if (client == null) {\n            IClientProfile profile =\n                    DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);\n            client = new DefaultAcsClient(profile);\n            DefaultProfile.addEndpoint(regionId, PRODUCT, END_POINT);\n        }\n\n        return client;\n    }\n\n    public void verify(HttpServletRequest httpRequest, CaptchaVerifyRequest captchaVerify) {\n        if (!captchaEnabled) {\n            return;\n        }\n\n        if (null == captchaVerify) {\n            throw UnauthorizedException.unauthorized(\"captcha_verify_empty\");\n        }\n\n        AuthenticateSigRequest request = new AuthenticateSigRequest();\n        request.setSessionId(captchaVerify.getSessionId()); // 会话ID。必填参数，从前端获取，不可更改。\n        request.setSig(captchaVerify.getSig()); // 签名串。必填参数，从前端获取，不可更改。\n        request.setToken(captchaVerify.getToken()); // 请求唯一标识。必填参数，从前端获取，不可更改。\n        request.setScene(captchaVerify.getScene()); // 场景标识。必填参数，从前端获取，不可更改。\n        request.setAppKey(captchaVerify.getAppKey()); // 应用类型标识。必填参数，后端填写。\n        request.setRemoteIp(IpUtils.getRealIpAddress(httpRequest)); // 客户端IP。必填参数，后端填写。\n\n\n        try {\n            // response的code枚举：100验签通过，900验签失败\n            AuthenticateSigResponse response = getClient().getAcsResponse(request);\n\n            if (!response.getCode().equals(100)) {\n                log.info(response.getMsg());\n            }\n        } catch (ClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n```","tags":["第三方集成"]},{"title":"checkstyle 使用","url":"/2021/05/29/2021-05-29-checkstyle/","content":"\n## checkstyle 使用\n\n### 在gradle中配置checkstyle\n```gradle\n    apply plugin: 'checkstyle'\n\n    checkstyle {\n            toolVersion = \"8.38\"\n            ignoreFailures = false\n            showViolations = true\n        }\n\n        task Checkstyle(type: Checkstyle) {\n            source = 'src/main/java'\n            include '**/*.java'\n            exclude '**/gen/**'\n            exclude '**/R.java'\n            exclude '**/BuildConfig.java'\n\n            classpath = files()\n        }\n```\n\n### checkstyle.xml\n默认路径 /config/checkstyle/checkstyle.xml\n\ngoogle 的checkstyle.xml，做了一些更改，尽量与IDEA保持一致，减少配置成本\n\n#### 主要更改\n- 每行最大字符数（与IDEA保持一致）\n```xml\n    <!--检查行长度-->\n    <module name=\"LineLength\">\n        <property name=\"fileExtensions\" value=\"java\"/>\n        <property name=\"max\" value=\"120\"/>\n        <property name=\"ignorePattern\" value=\"^package.*|^import.*|a href|href|http://|https://|ftp://\"/>\n    </module>\n```\n- 缩进，4个字符（换行策略与IDEA保持一致）\n```xml\n    <!--检查Java代码的正确缩进-->\n    <module name=\"Indentation\">\n        <!--换行默认缩进字符数-->\n        <property name=\"basicOffset\" value=\"4\" /><!--mine-->\n        <!--在下一行时，大括号应缩进多远-->\n        <property name=\"braceAdjustment\" value=\"0\" />\n        <property name=\"caseIndent\" value=\"4\" /><!--mine-->\n        <property name=\"throwsIndent\" value=\"4\" />\n        <property name=\"lineWrappingIndentation\" value=\"8\" />\n        <property name=\"arrayInitIndent\" value=\"4\" /><!--mine-->\n    </module>\n```\n- 不检查连续大写字母的长度，AABBcc是可被接受的\n```xml\n    <!--<module name=\"AbbreviationAsWordInName\">-->\n```\n- import顺序，第三方 -> javax|java -> static（与IDEA保持一致）\n ```xml\n <!--检查导入声明组是否按用户指定的顺序显示-->\n        <module name=\"CustomImportOrder\">\n            <property name=\"customImportOrderRules\"\n                      value=\"THIRD_PARTY_PACKAGE###SPECIAL_IMPORTS###STANDARD_JAVA_PACKAGE###STATIC\"/>\n            <property name=\"specialImportsRegExp\" value=\"^javax\\.\"/>\n            <property name=\"standardPackageRegExp\" value=\"^java\\.\"/>\n            <!--是否按字母顺序导包-->\n            <property name=\"sortImportsInGroupAlphabetically\" value=\"true\"/>\n            <property name=\"separateLineBetweenGroups\" value=\"false\"/>\n        </module>\n ```\n - 暂不考虑Javadoc\n - \n\n\n#### 全部设置\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE module PUBLIC\n        \"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\"\n        \"https://checkstyle.org/dtds/configuration_1_3.dtd\">\n\n<!--\n    Checkstyle configuration that checks the Google coding conventions from Google Java Style\n    that can be found at https://google.github.io/styleguide/javaguide.html\n\n    Checkstyle is very configurable. Be sure to read the documentation at\n    http://checkstyle.org (or in your downloaded distribution).\n\n    To completely disable a check, just comment it out or delete it from the file.\n    To suppress certain violations please review suppression filters.\n\n    Authors: Max Vetrenko, Ruslan Diachenko, Roman Ivanov.\n -->\n\n<module name = \"Checker\">\n    <!--字符集编码-->\n    <property name=\"charset\" value=\"UTF-8\"/>\n    <!--违规级别-->\n    <property name=\"severity\" value=\"warning\"/>\n    <!--可接受的文件扩展名-->\n    <property name=\"fileExtensions\" value=\"java, properties, xml\"/>\n    <!-- Excludes all 'module-info.java' files              -->\n    <!-- See https://checkstyle.org/config_filefilters.html -->\n    <module name=\"BeforeExecutionExclusionFileFilter\">\n        <property name=\"fileNamePattern\" value=\"module\\-info\\.java$\"/>\n    </module>\n    <!-- https://checkstyle.org/config_filters.html#SuppressionFilter -->\n    <module name=\"SuppressionFilter\">\n        <property name=\"file\" value=\"${config_loc}/checkstyle-suppressions.xml\"/>\n        <property name=\"optional\" value=\"true\"/>\n    </module>\n\n    <!-- Checks for whitespace                               -->\n    <!-- See http://checkstyle.org/config_whitespace.html -->\n    <!--检查文件是否包含制表符-->\n    <module name=\"FileTabCharacter\">\n        <property name=\"eachLine\" value=\"true\"/>\n    </module>\n    <!--检查行长度-->\n    <module name=\"LineLength\">\n        <property name=\"fileExtensions\" value=\"java\"/>\n        <property name=\"max\" value=\"120\"/>\n        <property name=\"ignorePattern\" value=\"^package.*|^import.*|a href|href|http://|https://|ftp://\"/>\n    </module>\n\n    <!--检查Java源文件并定义一些适用于检查此类文件的一些属性-->\n    <module name=\"TreeWalker\">\n        <!--检查外部类型名称和文件名是否匹配，例如，类Foo必须位于名为Foo.java的文件中-->\n        <module name=\"OuterTypeFilename\"/>\n        <!--检查不合规的文本-->\n        <module name=\"IllegalTokenText\">\n            <property name=\"tokens\" value=\"STRING_LITERAL, CHAR_LITERAL\"/>\n            <property name=\"format\"\n                      value=\"\\\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\\\(0(10|11|12|14|15|42|47)|134)\"/>\n            <property name=\"message\"\n                      value=\"Consider using special escape sequence instead of octal value or Unicode escaped value.\"/>\n        </module>\n        <!--限制使用Unicode转义-->\n        <module name=\"AvoidEscapedUnicodeCharacters\">\n            <property name=\"allowEscapesForControlCharacters\" value=\"true\"/>\n            <property name=\"allowByTailComment\" value=\"true\"/>\n            <property name=\"allowNonPrintableEscapes\" value=\"true\"/>\n        </module>\n        <!--检查使用*表示的import语句-->\n        <module name=\"AvoidStarImport\"/>\n        <!--检查每个顶级类，接口或枚举是否驻留在自己的源文件中-->\n        <module name=\"OneTopLevelClass\"/>\n        <!--检查所选语句是否不是换行的-->\n        <module name=\"NoLineWrap\">\n            <property name=\"tokens\" value=\"PACKAGE_DEF, IMPORT, STATIC_IMPORT\"/>\n        </module>\n        <!--检查空块但不验证顺序块-->\n        <module name=\"EmptyBlock\">\n            <property name=\"option\" value=\"TEXT\"/>\n            <property name=\"tokens\"\n                      value=\"LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH\"/>\n        </module>\n        <!--检查代码块周围的大括号-->\n        <module name=\"NeedBraces\">\n            <property name=\"tokens\"\n                      value=\"LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE\"/>\n            <!--允许没有大括号的单行语句-->\n            <!--<property name=\"allowSingleLineStatement\" value=\"true\" />-->\n        </module>\n        <!--检查代码块的左花括号（'{'）的位置-->\n        <module name=\"LeftCurly\">\n            <property name=\"tokens\"\n                      value=\"ANNOTATION_DEF, CLASS_DEF, CTOR_DEF, ENUM_CONSTANT_DEF, ENUM_DEF,\n                    INTERFACE_DEF, LAMBDA, LITERAL_CASE, LITERAL_CATCH, LITERAL_DEFAULT,\n                    LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF,\n                    LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, METHOD_DEF,\n                    OBJBLOCK, STATIC_INIT, RECORD_DEF, COMPACT_CTOR_DEF\"/>\n        </module>\n        <!--检查代码块的右花括号（'}'）的位置-->\n        <module name=\"RightCurly\">\n            <property name=\"id\" value=\"RightCurlySame\"/>\n            <property name=\"tokens\"\n                      value=\"LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE,\n                    LITERAL_DO\"/>\n        </module>\n        <module name=\"RightCurly\">\n            <property name=\"id\" value=\"RightCurlyAlone\"/>\n            <property name=\"option\" value=\"alone\"/>\n            <property name=\"tokens\"\n                      value=\"CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT,\n                    INSTANCE_INIT, ANNOTATION_DEF, ENUM_DEF, INTERFACE_DEF, RECORD_DEF,\n                    COMPACT_CTOR_DEF\"/>\n        </module>\n        <module name=\"SuppressionXpathSingleFilter\">\n            <!-- suppresion is required till https://github.com/checkstyle/checkstyle/issues/7541 -->\n            <property name=\"id\" value=\"RightCurlyAlone\"/>\n            <property name=\"query\" value=\"//RCURLY[parent::SLIST[count(./*)=1]\n                                     or preceding-sibling::*[last()][self::LCURLY]]\"/>\n        </module>\n        <module name=\"WhitespaceAfter\">\n            <property name=\"tokens\"\n                      value=\"COMMA, SEMI, TYPECAST, LITERAL_IF, LITERAL_ELSE,\n                    LITERAL_WHILE, LITERAL_DO, LITERAL_FOR, DO_WHILE\"/>\n        </module>\n        <!--检查令牌是否被空格包围-->\n        <module name=\"WhitespaceAround\">\n            <property name=\"allowEmptyConstructors\" value=\"true\"/>\n            <property name=\"allowEmptyLambdas\" value=\"true\"/>\n            <property name=\"allowEmptyMethods\" value=\"true\"/>\n            <property name=\"allowEmptyTypes\" value=\"true\"/>\n            <property name=\"allowEmptyLoops\" value=\"true\"/>\n            <property name=\"ignoreEnhancedForColon\" value=\"false\"/>\n            <property name=\"tokens\"\n                      value=\"ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR,\n                    BXOR_ASSIGN, COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAMBDA, LAND,\n                    LCURLY, LE, LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY,\n                    LITERAL_FOR, LITERAL_IF, LITERAL_RETURN, LITERAL_SWITCH, LITERAL_SYNCHRONIZED,\n                    LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS, MINUS_ASSIGN, MOD, MOD_ASSIGN,\n                    NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, RCURLY, SL, SLIST, SL_ASSIGN, SR,\n                    SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND\"/>\n            <message key=\"ws.notFollowed\"\n                     value=\"WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement (4.1.3)\"/>\n            <message key=\"ws.notPreceded\"\n                     value=\"WhitespaceAround: ''{0}'' is not preceded with whitespace.\"/>\n        </module>\n        <!--检查每行只有一个语句-->\n        <module name=\"OneStatementPerLine\"/>\n        <!--检查每个变量声明是否在它自己的语句中并且在它自己的行中-->\n        <module name=\"MultipleVariableDeclarations\"/>\n        <!--检查数组类型定义的样式-->\n        <module name=\"ArrayTypeStyle\"/>\n        <!--检查switch语句是否具有“default”子句-->\n        <module name=\"MissingSwitchDefault\"/>\n        <!--检查switch语句-->\n        <module name=\"FallThrough\"/>\n        <!--检查常量是否用大写定义-->\n        <module name=\"UpperEll\"/>\n        <!--检查修饰符是否符合Java建议-->\n        <module name=\"ModifierOrder\"/>\n        <!--检查空行分隔符-->\n        <module name=\"EmptyLineSeparator\">\n            <property name=\"tokens\"\n                      value=\"PACKAGE_DEF, IMPORT, STATIC_IMPORT, CLASS_DEF, INTERFACE_DEF, ENUM_DEF,\n                    STATIC_INIT, INSTANCE_INIT, METHOD_DEF, CTOR_DEF, VARIABLE_DEF, RECORD_DEF,\n                    COMPACT_CTOR_DEF\"/>\n            <!--字段之间不允许空行-->\n            <property name=\"allowNoEmptyLineBetweenFields\" value=\"true\"/>\n        </module>\n        <!--检查使用分隔符的换行-->\n        <module name=\"SeparatorWrap\">\n            <property name=\"id\" value=\"SeparatorWrapDot\"/>\n            <property name=\"tokens\" value=\"DOT\"/>\n            <property name=\"option\" value=\"nl\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <property name=\"id\" value=\"SeparatorWrapComma\"/>\n            <property name=\"tokens\" value=\"COMMA\"/>\n            <property name=\"option\" value=\"EOL\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <!-- ELLIPSIS is EOL until https://github.com/google/styleguide/issues/258 -->\n            <property name=\"id\" value=\"SeparatorWrapEllipsis\"/>\n            <property name=\"tokens\" value=\"ELLIPSIS\"/>\n            <property name=\"option\" value=\"EOL\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <!-- ARRAY_DECLARATOR is EOL until https://github.com/google/styleguide/issues/259 -->\n            <property name=\"id\" value=\"SeparatorWrapArrayDeclarator\"/>\n            <property name=\"tokens\" value=\"ARRAY_DECLARATOR\"/>\n            <property name=\"option\" value=\"EOL\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <property name=\"id\" value=\"SeparatorWrapMethodRef\"/>\n            <property name=\"tokens\" value=\"METHOD_REF\"/>\n            <property name=\"option\" value=\"nl\"/>\n        </module>\n        <!--检查包名称是否符合format属性指定的格式-->\n        <module name=\"PackageName\">\n            <property name=\"format\" value=\"^[a-z]+(\\.[a-z][a-z0-9]*)*$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Package name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查类型名称是否符合format属性指定的格式-->\n        <module name=\"TypeName\">\n            <property name=\"tokens\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF,\n                    ANNOTATION_DEF, RECORD_DEF\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查实例变量名称是否符合format属性指定的格式-->\n        <module name=\"MemberName\">\n            <property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9]*$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Member name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查参数名称是否符合format属性指定的格式-->\n        <module name=\"ParameterName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Parameter name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查以验证lambda参数名称-->\n        <module name=\"LambdaParameterName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Lambda parameter name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查catch参数名称是否符合format属性指定的格式-->\n        <module name=\"CatchParameterName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Catch parameter name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查本地、非final变量名称是否符合format属性指定的格式-->\n        <module name=\"LocalVariableName\">\n            <property name=\"format\" value=\"^[a-z]([a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Local variable name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"PatternVariableName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Pattern variable name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查类类型参数名称是否符合format属性指定的格式-->\n        <module name=\"ClassTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Class type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"RecordTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Record type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查方法类型参数名称是否符合format属性指定的格式-->\n        <module name=\"MethodTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Method type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查接口类型参数名称是否符合format属性指定的格式-->\n        <module name=\"InterfaceTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Interface type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--验证类中没有定义finalize()方法-->\n        <module name=\"NoFinalizer\"/>\n        <module name=\"GenericWhitespace\">\n            <message key=\"ws.followed\"\n                     value=\"GenericWhitespace ''{0}'' is followed by whitespace.\"/>\n            <message key=\"ws.preceded\"\n                     value=\"GenericWhitespace ''{0}'' is preceded with whitespace.\"/>\n            <message key=\"ws.illegalFollow\"\n                     value=\"GenericWhitespace ''{0}'' should followed by whitespace.\"/>\n            <message key=\"ws.notPreceded\"\n                     value=\"GenericWhitespace ''{0}'' is not preceded with whitespace.\"/>\n        </module>\n        <!--检查Java代码的正确缩进-->\n        <module name=\"Indentation\">\n            <!--换行默认缩进字符数-->\n            <property name=\"basicOffset\" value=\"4\" /><!--mine-->\n            <!--在下一行时，大括号应缩进多远-->\n            <property name=\"braceAdjustment\" value=\"0\" />\n            <property name=\"caseIndent\" value=\"4\" /><!--mine-->\n            <property name=\"throwsIndent\" value=\"4\" />\n            <property name=\"lineWrappingIndentation\" value=\"8\" />\n            <property name=\"arrayInitIndent\" value=\"4\" /><!--mine-->\n        </module>\n        <!--检查连续大写字母的长度-->\n        <!--        <module name=\"AbbreviationAsWordInName\">-->\n<!--            <property name=\"ignoreFinal\" value=\"false\"/>-->\n<!--            <property name=\"allowedAbbreviationLength\" value=\"4\"/>-->\n<!--            <property name=\"tokens\"-->\n<!--                      value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, ANNOTATION_DEF, ANNOTATION_FIELD_DEF,-->\n<!--                    PARAMETER_DEF, VARIABLE_DEF, METHOD_DEF, PATTERN_VARIABLE_DEF, RECORD_DEF,-->\n<!--                    RECORD_COMPONENT_DEF\"/>-->\n<!--        </module>-->\n        <!--检查重载方法是否组合在一起-->\n        <module name=\"OverloadMethodsDeclarationOrder\"/>\n        <!--检查变量声明与其首次使用之间的距离-->\n        <module name=\"VariableDeclarationUsageDistance\"/>\n        <!--检查导入声明组是否按用户指定的顺序显示-->\n        <module name=\"CustomImportOrder\">\n            <property name=\"customImportOrderRules\"\n                      value=\"THIRD_PARTY_PACKAGE###SPECIAL_IMPORTS###STANDARD_JAVA_PACKAGE###STATIC\"/>\n            <property name=\"specialImportsRegExp\" value=\"^javax\\.\"/>\n            <property name=\"standardPackageRegExp\" value=\"^java\\.\"/>\n            <!--是否按字母顺序导包-->\n            <property name=\"sortImportsInGroupAlphabetically\" value=\"true\"/>\n            <property name=\"separateLineBetweenGroups\" value=\"false\"/>\n        </module>\n        <!--检查方法名称和左括号之间的空格-->\n        <module name=\"MethodParamPad\">\n            <property name=\"tokens\"\n                      value=\"CTOR_DEF, LITERAL_NEW, METHOD_CALL, METHOD_DEF,\n                    SUPER_CTOR_CALL, ENUM_CONSTANT_DEF, RECORD_DEF\"/>\n        </module>\n        <!--检查tokens指定的字符前面是否有空格-->\n        <module name=\"NoWhitespaceBefore\">\n            <property name=\"tokens\"\n                      value=\"COMMA, SEMI, POST_INC, POST_DEC, DOT,\n                    LABELED_STAT, METHOD_REF\"/>\n            <property name=\"allowLineBreaks\" value=\"true\"/>\n        </module>\n        <!--检查左括号后和右括号前是否需要空格-->\n        <module name=\"ParenPad\">\n            <property name=\"tokens\"\n                      value=\"ANNOTATION, ANNOTATION_FIELD_DEF, CTOR_CALL, CTOR_DEF, DOT, ENUM_CONSTANT_DEF,\n                    EXPR, LITERAL_CATCH, LITERAL_DO, LITERAL_FOR, LITERAL_IF, LITERAL_NEW,\n                    LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_WHILE, METHOD_CALL,\n                    METHOD_DEF, QUESTION, RESOURCE_SPECIFICATION, SUPER_CTOR_CALL, LAMBDA,\n                    RECORD_DEF\"/>\n        </module>\n        <!--检查运算符上换行的策略-->\n        <!--与IDE默认行为不一致-->\n        <!--        <module name=\"OperatorWrap\">-->\n<!--            <property name=\"option\" value=\"NL\"/>-->\n<!--            <property name=\"tokens\"-->\n<!--                      value=\"BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR,-->\n<!--                    LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR, METHOD_REF \"/>-->\n<!--        </module>-->\n        <!--检查语言元素上注释的位置-->\n        <module name=\"AnnotationLocation\">\n            <property name=\"id\" value=\"AnnotationLocationMostCases\"/>\n            <property name=\"tokens\"\n                      value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF,\n                      RECORD_DEF, COMPACT_CTOR_DEF\"/>\n        </module>\n        <module name=\"AnnotationLocation\">\n            <property name=\"id\" value=\"AnnotationLocationVariables\"/>\n            <property name=\"tokens\" value=\"VARIABLE_DEF\"/>\n            <property name=\"allowSamelineMultipleAnnotations\" value=\"true\"/>\n        </module>\n        <!--检查@子句后面的描述是否为空-->\n        <module name=\"NonEmptyAtclauseDescription\"/>\n        <module name=\"InvalidJavadocPosition\"/>\n        <!--检查@子句的缩进-->\n        <!--        <module name=\"JavadocTagContinuationIndentation\"/>-->\n<!--        <module name=\"SummaryJavadoc\">-->\n<!--            <property name=\"forbiddenSummaryFragments\"-->\n<!--                      value=\"^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )\"/>-->\n<!--        </module>-->\n        <!--检查Javadoc段落-->\n        <module name=\"JavadocParagraph\"/>\n        <module name=\"RequireEmptyLineBeforeBlockTagGroup\"/>\n        <!--检查@子句的顺序-->\n        <module name=\"AtclauseOrder\">\n            <property name=\"tagOrder\" value=\"@param, @return, @throws, @deprecated\"/>\n            <property name=\"target\"\n                      value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF\"/>\n        </module>\n        <!--检查方法或构造函数的Javadoc-->\n        <module name=\"JavadocMethod\">\n            <property name=\"scope\" value=\"public\"/>\n            <property name=\"allowMissingParamTags\" value=\"true\"/>\n            <property name=\"allowMissingReturnTag\" value=\"true\"/>\n            <property name=\"allowedAnnotations\" value=\"Override, Test\"/>\n            <property name=\"tokens\" value=\"METHOD_DEF, CTOR_DEF, ANNOTATION_FIELD_DEF, COMPACT_CTOR_DEF\"/>\n        </module>\n<!--        <module name=\"MissingJavadocMethod\">-->\n<!--            <property name=\"scope\" value=\"public\"/>-->\n<!--            <property name=\"minLineCount\" value=\"2\"/>-->\n<!--            <property name=\"allowedAnnotations\" value=\"Override, Test\"/>-->\n<!--            <property name=\"tokens\" value=\"METHOD_DEF, CTOR_DEF, ANNOTATION_FIELD_DEF,-->\n<!--                                   COMPACT_CTOR_DEF\"/>-->\n<!--        </module>-->\n<!--        <module name=\"MissingJavadocType\">-->\n<!--            <property name=\"scope\" value=\"protected\"/>-->\n<!--            <property name=\"tokens\"-->\n<!--                      value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF,-->\n<!--                      RECORD_DEF, ANNOTATION_DEF\"/>-->\n<!--            <property name=\"excludeScope\" value=\"nothing\"/>-->\n<!--        </module>-->\n        <!--检查方法名称是否符合format属性指定的格式-->\n        <module name=\"MethodName\">\n            <property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9_]*$\"/>\n            <message key=\"name.invalidPattern\"\n                     value=\"Method name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <!--检查JavaDoc块是否可以放在一行中，并且不包含@子句-->\n        <module name=\"SingleLineJavadoc\">\n            <property name=\"ignoreInlineTags\" value=\"false\"/>\n        </module>\n        <!--检查空catch块-->\n        <module name=\"EmptyCatchBlock\">\n            <property name=\"exceptionVariableName\" value=\"expected\"/>\n        </module>\n        <!--控制注释和周围代码之间的缩进-->\n        <!--与IDE默认行为不一致-->\n        <!--        <module name=\"CommentsIndentation\">-->\n<!--            <property name=\"tokens\" value=\"SINGLE_LINE_COMMENT, BLOCK_COMMENT_BEGIN\"/>-->\n<!--        </module>-->\n        <!-- https://checkstyle.org/config_filters.html#SuppressionXpathFilter -->\n        <module name=\"SuppressionXpathFilter\">\n            <property name=\"file\" value=\"${org.checkstyle.google.suppressionxpathfilter.config}\"\n                      default=\"checkstyle-xpath-suppressions.xml\" />\n            <property name=\"optional\" value=\"true\"/>\n        </module>\n    </module>\n</module>\n\n\n```\n\n\n","tags":["后端","代码规范"]}]