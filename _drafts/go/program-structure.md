## 命名
命名规则：以一个字母或下划线开头
访问范围：
- 在函数内部定义，那么它就只在函数内部有效。
- 在函数外部定义，那么将在当前包的所有文件中都可以访问。
- 包外可访问，名字的开头字母的大小写决定了名字在包外的可见性。以大写字母开头，可以被外部的包访问。

## 声明
- var，变量
- const，常量
- type，类型
- func，函数

## 变量
一个变量对应一个保存了变量对应类型值的内存空间。

- var 变量名字 类型（自动初始化零值）
- var 变量名字 = 表达式
- 名字 := 表达式（简明对象声明，未声明的声明，已声明的赋值，但必须至少要声明一个新的变量）

ps：接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil

#### 指针
一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。
并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。
```go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```
变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作。
指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。

每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。例如，*p就是变量v的别名。

指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）。

不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。

#### new函数
new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。
用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外。
换言之，new函数类似是一种语法糖
```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

#### 生命周期
变量的生命周期指的是在程序运行期间变量有效存在的时间段。
- 包一级声明的变量，生命周期和整个程序的运行周期是一致的。
- 局部变量的生命周期是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。
ps：
垃圾回收基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

## 赋值
```go
// 交换
x, y = y, x

// 丢弃不需要的值
_, ok = m[key] 
```

## 类型
type 类型名字 底层类型

变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小，它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。
新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

类型转换不会改变值本身，但是会使它们的语义发生变化

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。

底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。

## 包和文件
Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。
一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中。

每个包都对应一个独立的名字空间。

包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化。
还有一些没有初始化表达式的，可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数。
```go
func init() { /* ... */ }
```
这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。

## 作用域
一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。

声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。
一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。

句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。

声明语句对应的词法域决定了作用域范围的大小。
对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。
任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。

在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。
